package controlapi

import (
	"net/http"
	"strings"

	"github.com/go-chi/render"
	"github.com/rafaeljc/heimdall/internal/store"
)

// handleCreateFlag processes the POST /api/v1/flags request.
//
// Responsibilities:
// 1. Decodes the JSON payload into the CreateFlagRequest DTO.
// 2. Sanitizes and Validates the input using the DTO's business logic.
// 3. Converts the DTO to the domain model (store.Flag).
// 4. Persists the flag using the Repository layer.
// 5. Handles specific persistence errors (e.g., conflicts).
// 6. Returns the created resource with a 201 Created status.
func (a *API) handleCreateFlag(w http.ResponseWriter, r *http.Request) {
	// 1. Decode Request
	var req CreateFlagRequest
	if err := render.DecodeJSON(r.Body, &req); err != nil {
		render.Status(r, http.StatusBadRequest)
		render.JSON(w, r, ErrorResponse{
			Code:    "ERR_INVALID_JSON",
			Message: "Invalid JSON payload: " + err.Error(),
		})
		return
	}

	// 2. Sanitize & Validate
	// We delegate this logic to the DTO to keep the handler clean and testable.
	// Sanitize modifies the struct in-place (trimming spaces, lowercasing keys).
	req.Sanitize()

	// Validate checks business rules (length, format, required fields).
	if errResp := req.Validate(); errResp != nil {
		render.Status(r, http.StatusBadRequest)
		render.JSON(w, r, errResp)
		return
	}

	// 3. Map DTO to Domain Model
	// We explicitly map fields to avoid coupling the API contract directly to the DB schema.
	flag := &store.Flag{
		Key:          req.Key,
		Name:         req.Name,
		Description:  req.Description,
		Enabled:      req.Enabled,
		DefaultValue: req.DefaultValue,
	}

	// 4. Call Repository (Persistence)
	if err := a.flags.CreateFlag(r.Context(), flag); err != nil {
		// Business Error: Conflict (Duplicate Key)
		// Ideally, the store should return a typed error (store.ErrDuplicate),
		// but checking the error string is acceptable for this V1 milestone.
		if strings.Contains(err.Error(), "already exists") {
			render.Status(r, http.StatusConflict)
			render.JSON(w, r, ErrorResponse{
				Code:    "ERR_CONFLICT",
				Message: "A flag with this key already exists",
			})
			return
		}

		// System Error: Internal Server Error
		// In a production system, we would log the full error stack trace here.
		render.Status(r, http.StatusInternalServerError)
		render.JSON(w, r, ErrorResponse{
			Code:    "ERR_INTERNAL",
			Message: "Failed to create flag in database",
		})
		return
	}

	// 5. Map Domain Model back to Response DTO
	// The 'flag' object now contains the ID and timestamps generated by the database.
	resp := Flag{
		ID:           flag.ID,
		Key:          flag.Key,
		Name:         flag.Name,
		Description:  flag.Description,
		Enabled:      flag.Enabled,
		DefaultValue: flag.DefaultValue,
		CreatedAt:    flag.CreatedAt,
		UpdatedAt:    flag.UpdatedAt,
	}

	// 6. Return Success
	render.Status(r, http.StatusCreated)
	render.JSON(w, r, resp)
}
