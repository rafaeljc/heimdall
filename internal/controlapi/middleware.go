package controlapi

import (
	"crypto/sha256"
	"crypto/subtle"
	"encoding/hex"
	"log/slog"
	"net/http"
	"strconv"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/render"
	"github.com/rafaeljc/heimdall/internal/logger"
	"github.com/rafaeljc/heimdall/internal/observability"
)

// RequestLogger creates a middleware that handles structured logging for HTTP requests.
// It performs three main tasks:
// 1. Derives a request-scoped logger enriched with the Request ID.
// 2. Injects this logger into the context for downstream handlers to use.
// 3. Logs the final outcome of the request (latency, status, method).
func RequestLogger(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		// 1. Resolve Request ID
		// Leverages Chi's RequestID middleware. Ensure Chi's middleware is mounted BEFORE this one.
		reqID := middleware.GetReqID(r.Context())
		if reqID == "" {
			reqID = "unknown" // Fallback safety
		}

		// 2. Create Contextual Logger
		// We take the configured default logger and create a child logger that
		// PERMANENTLY attaches the request_id to every log line generated by this request.
		reqLogger := slog.Default().With(
			slog.String("request_id", reqID),
		)

		// 3. Inject Logger into Context
		// Now, handlers like 'handleCreateFlag' can simply call logger.FromContext(ctx)
		// and get this pre-configured logger instance.
		ctx := logger.WithContext(r.Context(), reqLogger)

		// 4. Wrap ResponseWriter (Chi helper) to capture status code
		ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

		// 5. Process Request (Passing the NEW context with the logger)
		next.ServeHTTP(ww, r.WithContext(ctx))

		// 6. Log Outcome
		duration := time.Since(start)
		status := ww.Status()

		// Dynamic Log Level based on Status Code
		level := slog.LevelInfo
		if status >= 500 {
			level = slog.LevelError
		} else if status >= 400 {
			level = slog.LevelWarn
		}

		// We use the reqLogger to emit this log.
		// Note: We don't need to pass "request_id" here again, it's already in the logger.
		reqLogger.Log(ctx, level, "http request completed",
			slog.String("method", r.Method),
			slog.String("path", r.URL.Path),
			slog.Int("status", status),
			slog.String("duration", duration.String()),
			slog.String("remote_ip", r.RemoteAddr),
		)
	})
}

// authenticateAPIKey is a middleware that validates the X-API-Key header
// against the configured API key hash using constant-time comparison.
//
// If skipAuth is enabled (typically in test environments), authentication
// is bypassed entirely.
//
// Security considerations:
// - Uses crypto/subtle.ConstantTimeCompare to prevent timing attacks
// - Never logs or returns the actual key or hash
// - Returns 401 Unauthorized for missing or invalid keys
func (a *API) authenticateAPIKey(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Skip authentication if configured (test/dev mode)
		if a.skipAuth {
			next.ServeHTTP(w, r)
			return
		}

		// Extract API key from X-API-Key header
		apiKey := r.Header.Get("X-API-Key")
		if apiKey == "" {
			render.Status(r, http.StatusUnauthorized)
			render.JSON(w, r, ErrorResponse{
				Code:    "ERR_UNAUTHORIZED",
				Message: "missing X-API-Key header",
			})
			return
		}

		// Hash the provided key using SHA-256
		hash := sha256.Sum256([]byte(apiKey))
		hashHex := hex.EncodeToString(hash[:])

		// Constant-time comparison to prevent timing attacks
		// Returns 1 if equal, 0 otherwise
		if subtle.ConstantTimeCompare([]byte(hashHex), []byte(a.apiKeyHash)) != 1 {
			render.Status(r, http.StatusUnauthorized)
			render.JSON(w, r, ErrorResponse{
				Code:    "ERR_UNAUTHORIZED",
				Message: "invalid API key",
			})
			return
		}

		// Authentication successful, proceed to handler
		next.ServeHTTP(w, r)
	})
}

// ObservabilityMiddleware collects RED metrics (Rate, Errors, Duration) for HTTP requests.
//
// NOTE: Cardinality Protection
// This middleware strictly relies on the Chi Router's normalized "Route Pattern" (e.g., "/flags/{key}")
// instead of the raw URL path. This prevents high-cardinality issues in Prometheus caused by
// dynamic IDs or malicious scanners probing random paths.
func ObservabilityMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		// Wrap ResponseWriter to capture the status code
		ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

		// Process the request
		next.ServeHTTP(ww, r)

		// --- Telemetry Logic ---

		duration := time.Since(start).Seconds()
		status := ww.Status()
		statusStr := strconv.Itoa(status)

		var routePattern string
		rctx := chi.RouteContext(r.Context())

		// 1. Business Context (High Priority):
		// If Chi matched a route (e.g., "/flags/{key}"), use that pattern.
		// This preserves visibility for cases where the route exists, but the resource (key) does not (404).
		if rctx != nil && rctx.RoutePattern() != "" {
			routePattern = rctx.RoutePattern()
		} else {
			// 2. Infrastructure Noise (Fallback):
			// If no route was matched, it's likely a 404 for a non-existent path (e.g., /admin.php, /favicon.ico).
			// We force "not_found" to prevent cardinality explosion from bots/scanners.
			routePattern = "not_found"
		}

		// Record Metrics
		// Labels must match definition in internal/observability/metrics.go
		observability.ControlPlaneReqDuration.WithLabelValues(r.Method, routePattern).Observe(duration)
		observability.ControlPlaneReqTotal.WithLabelValues(r.Method, routePattern, statusStr).Inc()
	})
}
